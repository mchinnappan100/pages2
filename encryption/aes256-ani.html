<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AES-256 Encryption Visualizer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="icon" type="image/x-icon" href="https://mohan-chinnappan-n5.github.io/dfv/img/mc_favIcon.ico" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/java.min.js"></script>
    <style>
        body {
            background: #0f172a;
        }
        .grid-cell {
            transition: all 0.5s ease;
        }
        .grid-cell.highlight {
            background: #3b82f6 !important;
            transform: scale(1.1);
        }
        .round-indicator {
            transition: all 0.3s ease;
        }
        .round-indicator.active {
            background: #10b981;
            transform: scale(1.2);
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .animating {
            animation: pulse 1s ease-in-out infinite;
        }
        .code-tab {
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .code-tab.active {
            background: #1e293b;
            border-bottom: 2px solid #3b82f6;
        }
        .file-upload-area {
            border: 2px dashed #475569;
            transition: all 0.3s ease;
        }
        .file-upload-area:hover {
            border-color: #3b82f6;
            background: #1e293b;
        }
        .file-upload-area.dragover {
            border-color: #10b981;
            background: #1e293b;
        }
    </style>
</head>
<body class="text-gray-100">
    <div class="container mx-auto px-4 py-8 max-w-7xl">
        <!-- Header -->
        <div class="text-center mb-12">
            <h1 class="text-5xl font-bold mb-4 bg-gradient-to-r from-blue-400 to-purple-500 bg-clip-text text-transparent">
                AES-256 Encryption Explained
            </h1>
            <p class="text-xl text-gray-300">Understanding Advanced Encryption Standard with 256-bit keys</p>
        </div>

        <!-- What is AES? -->
        <div class="bg-slate-800 rounded-lg p-6 mb-8 border border-slate-700">
            <h2 class="text-3xl font-bold mb-4 text-blue-400">üîê What is AES-256?</h2>
            <div class="space-y-3 text-gray-300">
                <p><strong class="text-blue-300">AES</strong> (Advanced Encryption Standard) is like a super-secure lock for your data!</p>
                <p><strong class="text-green-300">256</strong> means it uses a 256-bit key (32 bytes) - that's really, really hard to crack!</p>
                <p><strong class="text-purple-300">Block Cipher:</strong> It works on 16-byte blocks (128 bits) at a time, arranged in a 4√ó4 grid</p>
                <p><strong class="text-yellow-300">14 Rounds:</strong> For AES-256, the data goes through 14 transformation rounds</p>
            </div>
        </div>

        <!-- Interactive Visualization -->
        <div class="bg-slate-800 rounded-lg p-6 mb-8 border border-slate-700">
            <h2 class="text-3xl font-bold mb-6 text-blue-400">üìä Interactive Visualization</h2>
            
            <!-- Controls -->
            <div class="flex gap-4 mb-6 flex-wrap">
                <button onclick="startEncryption()" class="bg-green-600 hover:bg-green-700 px-6 py-3 rounded-lg font-semibold transition">
                    üîí Encrypt
                </button>
                <button onclick="startDecryption()" class="bg-purple-600 hover:bg-purple-700 px-6 py-3 rounded-lg font-semibold transition">
                    üîì Decrypt
                </button>
                <button onclick="resetAnimation()" class="bg-gray-600 hover:bg-gray-700 px-6 py-3 rounded-lg font-semibold transition">
                    ‚Ü∫ Reset
                </button>
            </div>

            <!-- Animation Display -->
            <div class="grid md:grid-cols-2 gap-8">
                <!-- Input State -->
                <div>
                    <h3 class="text-xl font-bold mb-4 text-center" id="inputLabel">Plaintext (16 bytes)</h3>
                    <div class="bg-slate-900 p-6 rounded-lg">
                        <div class="grid grid-cols-4 gap-2" id="inputGrid">
                            <!-- Will be filled by JavaScript -->
                        </div>
                    </div>
                </div>

                <!-- Output State -->
                <div>
                    <h3 class="text-xl font-bold mb-4 text-center" id="outputLabel">Ciphertext</h3>
                    <div class="bg-slate-900 p-6 rounded-lg">
                        <div class="grid grid-cols-4 gap-2" id="outputGrid">
                            <!-- Will be filled by JavaScript -->
                        </div>
                    </div>
                </div>
            </div>

            <!-- Round Indicator -->
            <div class="mt-8">
                <h3 class="text-xl font-bold mb-4 text-center">Current Round: <span id="roundNumber">0</span> / 14</h3>
                <div class="flex gap-2 justify-center flex-wrap" id="roundIndicators">
                    <!-- Will be filled by JavaScript -->
                </div>
            </div>

            <!-- Current Operation -->
            <div class="mt-6 bg-slate-900 p-4 rounded-lg text-center">
                <p class="text-lg"><strong>Current Step:</strong> <span id="currentStep" class="text-blue-400">Ready to start</span></p>
            </div>
        </div>

        <!-- File Encryption Demo -->
        <div class="bg-slate-800 rounded-lg p-6 mb-8 border border-slate-700">
            <h2 class="text-3xl font-bold mb-6 text-blue-400">üìÅ Try AES-256 on Your Own File!</h2>
            
            <div class="grid md:grid-cols-2 gap-6">
                <!-- File Upload -->
                <div>
                    <h3 class="text-xl font-bold mb-4 text-green-400">Step 1: Upload a Text File</h3>
                    <div class="file-upload-area bg-slate-900 p-8 rounded-lg text-center cursor-pointer" 
                         id="fileUploadArea"
                         onclick="document.getElementById('fileInput').click()">
                        <input type="file" id="fileInput" accept=".txt" class="hidden" onchange="handleFileUpload(event)">
                        <div id="uploadPrompt">
                            <svg class="mx-auto mb-4 w-16 h-16 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"/>
                            </svg>
                            <p class="text-gray-300 mb-2">Click to upload or drag and drop</p>
                            <p class="text-sm text-gray-500">Text files (.txt) only</p>
                        </div>
                        <div id="uploadedInfo" class="hidden">
                            <svg class="mx-auto mb-4 w-16 h-16 text-green-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/>
                            </svg>
                            <p class="text-green-400 font-bold" id="fileName"></p>
                            <p class="text-sm text-gray-400" id="fileSize"></p>
                        </div>
                    </div>
                    
                    <!-- Encryption Key Input -->
                    <div class="mt-4">
                        <label class="block text-sm font-bold mb-2 text-gray-300">Encryption Key (32 characters for AES-256)</label>
                        <input type="text" 
                               id="encryptionKey" 
                               placeholder="Enter your secret key here..."
                               maxlength="32"
                               class="w-full bg-slate-900 border border-slate-600 rounded-lg px-4 py-3 text-gray-100 focus:border-blue-500 focus:outline-none"
                               value="my-super-secret-256bit-key!!">
                        <p class="text-xs text-gray-500 mt-1">Key length: <span id="keyLength">32</span>/32 characters</p>
                    </div>
                </div>

                <!-- Preview and Actions -->
                <div>
                    <h3 class="text-xl font-bold mb-4 text-purple-400">Step 2: Encrypt or Decrypt</h3>
                    
                    <!-- File Content Preview -->
                    <div class="bg-slate-900 p-4 rounded-lg mb-4">
                        <p class="text-sm font-bold text-gray-400 mb-2">File Content Preview:</p>
                        <div id="filePreview" class="bg-slate-950 p-3 rounded font-mono text-sm text-gray-300 max-h-40 overflow-auto">
                            <p class="text-gray-500 italic">Upload a file to see preview...</p>
                        </div>
                    </div>

                    <!-- Action Buttons -->
                    <div class="flex gap-3 mb-4">
                        <button onclick="encryptFile()" 
                                id="encryptBtn"
                                disabled
                                class="flex-1 bg-green-600 hover:bg-green-700 disabled:bg-gray-600 disabled:cursor-not-allowed px-6 py-3 rounded-lg font-semibold transition">
                            üîí Encrypt File
                        </button>
                        <button onclick="decryptFile()" 
                                id="decryptBtn"
                                disabled
                                class="flex-1 bg-purple-600 hover:bg-purple-700 disabled:bg-gray-600 disabled:cursor-not-allowed px-6 py-3 rounded-lg font-semibold transition">
                            üîì Decrypt File
                        </button>
                    </div>

                    <!-- Result -->
                    <div id="fileResult" class="hidden bg-slate-900 p-4 rounded-lg">
                        <div class="flex justify-between items-center mb-3">
                            <p class="text-sm font-bold text-gray-400">Result:</p>
                            <button onclick="downloadResult()" class="bg-blue-600 hover:bg-blue-700 px-4 py-2 rounded text-sm font-semibold transition">
                                ‚¨áÔ∏è Download
                            </button>
                        </div>
                        <div id="resultPreview" class="bg-slate-950 p-3 rounded font-mono text-sm text-gray-300 max-h-40 overflow-auto break-all">
                        </div>
                    </div>

                    <!-- Stats -->
                    <div id="encryptionStats" class="hidden mt-4 grid grid-cols-2 gap-3">
                        <div class="bg-blue-900/30 p-3 rounded">
                            <p class="text-xs text-gray-400">Original Size</p>
                            <p class="text-lg font-bold text-blue-400" id="originalSize">-</p>
                        </div>
                        <div class="bg-purple-900/30 p-3 rounded">
                            <p class="text-xs text-gray-400">Encrypted Size</p>
                            <p class="text-lg font-bold text-purple-400" id="encryptedSize">-</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- The 4 Main Operations -->
        <div class="bg-slate-800 rounded-lg p-6 mb-8 border border-slate-700">
            <h2 class="text-3xl font-bold mb-6 text-blue-400">üîÑ The Four Main Operations (Each Round)</h2>
            
            <div class="grid md:grid-cols-2 gap-6">
                <div class="bg-slate-900 p-5 rounded-lg border-l-4 border-blue-500">
                    <h3 class="text-xl font-bold mb-3 text-blue-300">1. SubBytes</h3>
                    <p class="text-gray-300">Each byte is replaced with another byte using a special lookup table (S-Box). Think of it like a secret code where A‚ÜíX, B‚ÜíQ, etc.</p>
                </div>

                <div class="bg-slate-900 p-5 rounded-lg border-l-4 border-green-500">
                    <h3 class="text-xl font-bold mb-3 text-green-300">2. ShiftRows</h3>
                    <p class="text-gray-300">Rows are shifted left by different amounts. Row 0 stays, Row 1 shifts 1 position, Row 2 shifts 2, Row 3 shifts 3.</p>
                </div>

                <div class="bg-slate-900 p-5 rounded-lg border-l-4 border-purple-500">
                    <h3 class="text-xl font-bold mb-3 text-purple-300">3. MixColumns</h3>
                    <p class="text-gray-300">Columns are mixed together using mathematical operations (matrix multiplication). This spreads the data around.</p>
                </div>

                <div class="bg-slate-900 p-5 rounded-lg border-l-4 border-yellow-500">
                    <h3 class="text-xl font-bold mb-3 text-yellow-300">4. AddRoundKey</h3>
                    <p class="text-gray-300">XOR (combine) the data with a round-specific key. This is where your password/key actually protects the data!</p>
                </div>
            </div>

            <div class="mt-6 bg-blue-900/30 p-4 rounded-lg">
                <p class="text-center text-gray-300"><strong>Note:</strong> In the final round, MixColumns is skipped. Decryption does these steps in reverse!</p>
            </div>
        </div>

        <!-- Code Examples -->
        <div class="bg-slate-800 rounded-lg p-6 mb-8 border border-slate-700">
            <h2 class="text-3xl font-bold mb-6 text-blue-400">üíª Implementation Examples</h2>
            
            <!-- Tabs -->
            <div class="flex gap-2 mb-4 border-b border-slate-700">
                <button class="code-tab active px-6 py-3 font-semibold" onclick="showCode('python')" id="pythonTab">
                    üêç Python
                </button>
                <button class="code-tab px-6 py-3 font-semibold" onclick="showCode('nodejs')" id="nodejsTab">
                    üìó Node.js
                </button>
                <button class="code-tab px-6 py-3 font-semibold" onclick="showCode('java')" id="javaTab">
                    ‚òï Java
                </button>
            </div>

            <!-- Python Code -->
            <div id="pythonCode" class="code-section">
                <pre><code class="language-python">from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes
from Crypto.Util.Padding import pad, unpad
import base64

class AES256Cipher:
    """Simple AES-256 encryption and decryption"""
    
    def __init__(self, key):
        """
        Initialize with a 32-byte (256-bit) key
        If key is a string, it will be converted to bytes
        """
        if isinstance(key, str):
            # Convert string to 32 bytes (pad or truncate)
            key = key.encode('utf-8')
            key = key[:32].ljust(32, b'\0')
        self.key = key
    
    def encrypt(self, plaintext):
        """
        Encrypt plaintext and return base64 encoded ciphertext
        
        Steps:
        1. Generate random IV (Initialization Vector)
        2. Create AES cipher in CBC mode
        3. Pad plaintext to 16-byte blocks
        4. Encrypt the data
        5. Return IV + ciphertext (base64 encoded)
        """
        # Convert string to bytes
        if isinstance(plaintext, str):
            plaintext = plaintext.encode('utf-8')
        
        # Generate random IV (16 bytes for AES)
        iv = get_random_bytes(16)
        
        # Create cipher object in CBC mode
        cipher = AES.new(self.key, AES.MODE_CBC, iv)
        
        # Pad plaintext to multiple of 16 bytes
        padded_plaintext = pad(plaintext, AES.block_size)
        
        # Encrypt the data
        ciphertext = cipher.encrypt(padded_plaintext)
        
        # Combine IV and ciphertext, then encode as base64
        return base64.b64encode(iv + ciphertext).decode('utf-8')
    
    def decrypt(self, encrypted_data):
        """
        Decrypt base64 encoded ciphertext and return plaintext
        
        Steps:
        1. Decode base64 data
        2. Extract IV (first 16 bytes)
        3. Extract ciphertext (remaining bytes)
        4. Create AES cipher with the IV
        5. Decrypt and unpad the data
        """
        # Decode base64
        encrypted_bytes = base64.b64decode(encrypted_data)
        
        # Extract IV (first 16 bytes)
        iv = encrypted_bytes[:16]
        
        # Extract ciphertext (rest of the bytes)
        ciphertext = encrypted_bytes[16:]
        
        # Create cipher object
        cipher = AES.new(self.key, AES.MODE_CBC, iv)
        
        # Decrypt and unpad
        decrypted_padded = cipher.decrypt(ciphertext)
        plaintext = unpad(decrypted_padded, AES.block_size)
        
        return plaintext.decode('utf-8')


# Example usage
if __name__ == "__main__":
    # Create a 256-bit key (32 bytes)
    key = "my-super-secret-256bit-key!!"  # Will be converted to 32 bytes
    
    # Create cipher object
    aes = AES256Cipher(key)
    
    # Original message
    message = "Hello, World! This is a secret message."
    print(f"Original: {message}")
    
    # Encrypt
    encrypted = aes.encrypt(message)
    print(f"Encrypted: {encrypted}")
    
    # Decrypt
    decrypted = aes.decrypt(encrypted)
    print(f"Decrypted: {decrypted}")
    
    # Verify
    assert message == decrypted, "Decryption failed!"
    print("‚úÖ Encryption and decryption successful!")


# Install required package:
# pip install pycryptodome
</code></pre>
            </div>

            <!-- Node.js Code -->
            <div id="nodejsCode" class="code-section hidden">
                <pre><code class="language-javascript">const crypto = require('crypto');

class AES256Cipher {
    /**
     * Initialize with a 32-byte (256-bit) key
     * @param {string|Buffer} key - Encryption key
     */
    constructor(key) {
        // Convert string to buffer if needed
        if (typeof key === 'string') {
            // Convert to buffer and ensure 32 bytes
            const keyBuffer = Buffer.from(key, 'utf-8');
            this.key = Buffer.alloc(32);
            keyBuffer.copy(this.key, 0, 0, Math.min(keyBuffer.length, 32));
        } else {
            this.key = key;
        }
        
        // AES-256 requires exactly 32 bytes
        if (this.key.length !== 32) {
            throw new Error('Key must be 32 bytes for AES-256');
        }
    }
    
    /**
     * Encrypt plaintext and return base64 encoded ciphertext
     * 
     * Steps:
     * 1. Generate random IV (Initialization Vector)
     * 2. Create AES-256-CBC cipher
     * 3. Encrypt the data
     * 4. Return IV + ciphertext (base64 encoded)
     * 
     * @param {string} plaintext - Text to encrypt
     * @returns {string} Base64 encoded encrypted data
     */
    encrypt(plaintext) {
        // Generate random IV (16 bytes for AES)
        const iv = crypto.randomBytes(16);
        
        // Create cipher with AES-256-CBC mode
        const cipher = crypto.createCipheriv('aes-256-cbc', this.key, iv);
        
        // Encrypt the data
        let encrypted = cipher.update(plaintext, 'utf8', 'hex');
        encrypted += cipher.final('hex');
        
        // Combine IV and encrypted data
        const combined = Buffer.concat([
            iv,
            Buffer.from(encrypted, 'hex')
        ]);
        
        // Return as base64
        return combined.toString('base64');
    }
    
    /**
     * Decrypt base64 encoded ciphertext and return plaintext
     * 
     * Steps:
     * 1. Decode base64 data
     * 2. Extract IV (first 16 bytes)
     * 3. Extract ciphertext (remaining bytes)
     * 4. Create AES-256-CBC decipher with the IV
     * 5. Decrypt the data
     * 
     * @param {string} encryptedData - Base64 encoded encrypted data
     * @returns {string} Decrypted plaintext
     */
    decrypt(encryptedData) {
        // Decode base64
        const encryptedBuffer = Buffer.from(encryptedData, 'base64');
        
        // Extract IV (first 16 bytes)
        const iv = encryptedBuffer.subarray(0, 16);
        
        // Extract ciphertext (rest of the bytes)
        const ciphertext = encryptedBuffer.subarray(16);
        
        // Create decipher
        const decipher = crypto.createDecipheriv('aes-256-cbc', this.key, iv);
        
        // Decrypt the data
        let decrypted = decipher.update(ciphertext, undefined, 'utf8');
        decrypted += decipher.final('utf8');
        
        return decrypted;
    }
}

// Example usage
function main() {
    // Create a 256-bit key (32 bytes)
    const key = "my-super-secret-256bit-key!!";
    
    // Create cipher object
    const aes = new AES256Cipher(key);
    
    // Original message
    const message = "Hello, World! This is a secret message.";
    console.log(`Original: ${message}`);
    
    // Encrypt
    const encrypted = aes.encrypt(message);
    console.log(`Encrypted: ${encrypted}`);
    
    // Decrypt
    const decrypted = aes.decrypt(encrypted);
    console.log(`Decrypted: ${decrypted}`);
    
    // Verify
    if (message === decrypted) {
        console.log('‚úÖ Encryption and decryption successful!');
    } else {
        console.error('‚ùå Decryption failed!');
    }
}

// Run the example
main();

// Node.js crypto module is built-in, no installation needed!
module.exports = AES256Cipher;
</code></pre>
            </div>

            <!-- Java Code -->
            <div id="javaCode" class="code-section hidden">
                <pre><code class="language-java">import javax.crypto.Cipher;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import java.nio.charset.StandardCharsets;
import java.security.SecureRandom;
import java.util.Base64;
import java.util.Arrays;

/**
 * AES-256 Encryption and Decryption in Java
 * 
 * This class provides simple methods to encrypt and decrypt text
 * using AES-256 encryption in CBC mode with PKCS5 padding.
 */
public class AES256Cipher {
    private static final String ALGORITHM = "AES";
    private static final String TRANSFORMATION = "AES/CBC/PKCS5Padding";
    private static final int KEY_SIZE = 32; // 256 bits = 32 bytes
    private static final int IV_SIZE = 16;  // 128 bits = 16 bytes
    
    private final SecretKeySpec secretKey;
    
    /**
     * Initialize with a 32-byte (256-bit) key
     * 
     * @param key Encryption key (will be adjusted to 32 bytes)
     */
    public AES256Cipher(String key) {
        byte[] keyBytes = key.getBytes(StandardCharsets.UTF_8);
        
        // Ensure key is exactly 32 bytes
        byte[] adjustedKey = new byte[KEY_SIZE];
        if (keyBytes.length >= KEY_SIZE) {
            System.arraycopy(keyBytes, 0, adjustedKey, 0, KEY_SIZE);
        } else {
            System.arraycopy(keyBytes, 0, adjustedKey, 0, keyBytes.length);
            // Remaining bytes are already 0
        }
        
        this.secretKey = new SecretKeySpec(adjustedKey, ALGORITHM);
    }
    
    /**
     * Encrypt plaintext and return base64 encoded ciphertext
     * 
     * Steps:
     * 1. Generate random IV (Initialization Vector)
     * 2. Create AES cipher in CBC mode
     * 3. Encrypt the data
     * 4. Combine IV + ciphertext
     * 5. Return as base64 string
     * 
     * @param plaintext Text to encrypt
     * @return Base64 encoded encrypted data (IV + ciphertext)
     * @throws Exception if encryption fails
     */
    public String encrypt(String plaintext) throws Exception {
        // Generate random IV
        byte[] iv = new byte[IV_SIZE];
        SecureRandom random = new SecureRandom();
        random.nextBytes(iv);
        IvParameterSpec ivSpec = new IvParameterSpec(iv);
        
        // Create and initialize cipher
        Cipher cipher = Cipher.getInstance(TRANSFORMATION);
        cipher.init(Cipher.ENCRYPT_MODE, secretKey, ivSpec);
        
        // Encrypt the plaintext
        byte[] encrypted = cipher.doFinal(plaintext.getBytes(StandardCharsets.UTF_8));
        
        // Combine IV and encrypted data
        byte[] combined = new byte[IV_SIZE + encrypted.length];
        System.arraycopy(iv, 0, combined, 0, IV_SIZE);
        System.arraycopy(encrypted, 0, combined, IV_SIZE, encrypted.length);
        
        // Return as base64
        return Base64.getEncoder().encodeToString(combined);
    }
    
    /**
     * Decrypt base64 encoded ciphertext and return plaintext
     * 
     * Steps:
     * 1. Decode base64 data
     * 2. Extract IV (first 16 bytes)
     * 3. Extract ciphertext (remaining bytes)
     * 4. Create AES cipher with the IV
     * 5. Decrypt the data
     * 
     * @param encryptedData Base64 encoded encrypted data
     * @return Decrypted plaintext
     * @throws Exception if decryption fails
     */
    public String decrypt(String encryptedData) throws Exception {
        // Decode base64
        byte[] combined = Base64.getDecoder().decode(encryptedData);
        
        // Extract IV (first 16 bytes)
        byte[] iv = Arrays.copyOfRange(combined, 0, IV_SIZE);
        IvParameterSpec ivSpec = new IvParameterSpec(iv);
        
        // Extract ciphertext (remaining bytes)
        byte[] ciphertext = Arrays.copyOfRange(combined, IV_SIZE, combined.length);
        
        // Create and initialize cipher
        Cipher cipher = Cipher.getInstance(TRANSFORMATION);
        cipher.init(Cipher.DECRYPT_MODE, secretKey, ivSpec);
        
        // Decrypt the data
        byte[] decrypted = cipher.doFinal(ciphertext);
        
        return new String(decrypted, StandardCharsets.UTF_8);
    }
    
    /**
     * Example usage demonstrating encryption and decryption
     */
    public static void main(String[] args) {
        try {
            // Create a 256-bit key (32 bytes)
            String key = "my-super-secret-256bit-key!!";
            
            // Create cipher object
            AES256Cipher aes = new AES256Cipher(key);
            
            // Original message
            String message = "Hello, World! This is a secret message.";
            System.out.println("Original: " + message);
            
            // Encrypt
            String encrypted = aes.encrypt(message);
            System.out.println("Encrypted: " + encrypted);
            
            // Decrypt
            String decrypted = aes.decrypt(encrypted);
            System.out.println("Decrypted: " + decrypted);
            
            // Verify
            if (message.equals(decrypted)) {
                System.out.println("‚úÖ Encryption and decryption successful!");
            } else {
                System.out.println("‚ùå Decryption failed!");
            }
            
        } catch (Exception e) {
            System.err.println("Error: " + e.getMessage());
            e.printStackTrace();
        }
    }
}

/*
 * Notes:
 * - Java's default JCE (Java Cryptography Extension) supports AES-256
 * - No external libraries needed for basic AES encryption
 * - For file encryption, use FileInputStream/FileOutputStream
 * - Always use SecureRandom for generating IVs
 * - Store IV with ciphertext (it doesn't need to be secret)
 * - Never reuse the same IV with the same key!
 */
</code></pre>
            </div>
        </div>

        <!-- Key Concepts -->
        <div class="bg-slate-800 rounded-lg p-6 mb-8 border border-slate-700">
            <h2 class="text-3xl font-bold mb-6 text-blue-400">üéØ Key Concepts to Remember</h2>
            
            <div class="space-y-4">
                <div class="bg-slate-900 p-4 rounded-lg">
                    <h3 class="font-bold text-lg text-green-400 mb-2">‚úÖ Symmetric Encryption</h3>
                    <p class="text-gray-300">AES uses the same key to encrypt AND decrypt. Keep this key secret!</p>
                </div>

                <div class="bg-slate-900 p-4 rounded-lg">
                    <h3 class="font-bold text-lg text-blue-400 mb-2">üî¢ Block Size vs Key Size</h3>
                    <p class="text-gray-300">Block = 128 bits (16 bytes) always. Key = 256 bits (32 bytes) for AES-256.</p>
                </div>

                <div class="bg-slate-900 p-4 rounded-lg">
                    <h3 class="font-bold text-lg text-purple-400 mb-2">üîÑ IV (Initialization Vector)</h3>
                    <p class="text-gray-300">A random starting value that makes the same plaintext encrypt to different ciphertexts each time.</p>
                </div>

                <div class="bg-slate-900 p-4 rounded-lg">
                    <h3 class="font-bold text-lg text-yellow-400 mb-2">üõ°Ô∏è Security</h3>
                    <p class="text-gray-300">AES-256 is military-grade encryption. It would take billions of years to crack with current computers!</p>
                </div>
            </div>
        </div>

        <!-- Footer -->
        <div class="text-center text-gray-400 text-sm">
            <p>Built with ‚ù§Ô∏è for learning | AES-256 Visualizer</p>
        </div>
    </div>

    <script>
        // File handling variables
        let uploadedFile = null;
        let fileContent = '';
        let encryptedContent = '';
        let isEncrypted = false;

        // Update key length counter
        document.addEventListener('DOMContentLoaded', function() {
            const keyInput = document.getElementById('encryptionKey');
            if (keyInput) {
                keyInput.addEventListener('input', function() {
                    document.getElementById('keyLength').textContent = this.value.length;
                });
            }
            
            // Setup drag and drop
            const uploadArea = document.getElementById('fileUploadArea');
            if (uploadArea) {
                uploadArea.addEventListener('dragover', function(e) {
                    e.preventDefault();
                    this.classList.add('dragover');
                });
                
                uploadArea.addEventListener('dragleave', function(e) {
                    e.preventDefault();
                    this.classList.remove('dragover');
                });
                
                uploadArea.addEventListener('drop', function(e) {
                    e.preventDefault();
                    this.classList.remove('dragover');
                    const files = e.dataTransfer.files;
                    if (files.length > 0) {
                        handleFileSelect(files[0]);
                    }
                });
            }
        });

        // Handle file upload
        function handleFileUpload(event) {
            const file = event.target.files[0];
            handleFileSelect(file);
        }

        function handleFileSelect(file) {
            if (!file) return;
            
            if (!file.name.endsWith('.txt')) {
                alert('Please upload a .txt file');
                return;
            }
            
            uploadedFile = file;
            const reader = new FileReader();
            
            reader.onload = function(e) {
                fileContent = e.target.result;
                isEncrypted = false;
                
                // Update UI
                document.getElementById('uploadPrompt').classList.add('hidden');
                document.getElementById('uploadedInfo').classList.remove('hidden');
                document.getElementById('fileName').textContent = file.name;
                document.getElementById('fileSize').textContent = formatFileSize(file.size);
                
                // Show preview
                const preview = fileContent.substring(0, 200);
                document.getElementById('filePreview').innerHTML = 
                    `<p class="whitespace-pre-wrap">${escapeHtml(preview)}${fileContent.length > 200 ? '...' : ''}</p>`;
                
                // Enable buttons
                document.getElementById('encryptBtn').disabled = false;
                document.getElementById('decryptBtn').disabled = true;
                
                // Hide result
                document.getElementById('fileResult').classList.add('hidden');
                document.getElementById('encryptionStats').classList.add('hidden');
            };
            
            reader.readAsText(file);
        }

        // Simple AES-256 encryption (using SubtleCrypto API)
        async function encryptFile() {
            if (!fileContent) {
                alert('Please upload a file first');
                return;
            }
            
            const key = document.getElementById('encryptionKey').value;
            if (key.length < 32) {
                alert('Key must be at least 32 characters for AES-256');
                return;
            }
            
            try {
                // Use Web Crypto API for real AES-256 encryption
                const encoder = new TextEncoder();
                const data = encoder.encode(fileContent);
                
                // Derive key from password
                const keyMaterial = await crypto.subtle.importKey(
                    'raw',
                    encoder.encode(key.padEnd(32, '0').substring(0, 32)),
                    'PBKDF2',
                    false,
                    ['deriveBits', 'deriveKey']
                );
                
                const cryptoKey = await crypto.subtle.deriveKey(
                    {
                        name: 'PBKDF2',
                        salt: encoder.encode('aes-demo-salt'),
                        iterations: 100000,
                        hash: 'SHA-256'
                    },
                    keyMaterial,
                    { name: 'AES-GCM', length: 256 },
                    true,
                    ['encrypt', 'decrypt']
                );
                
                // Generate random IV
                const iv = crypto.getRandomValues(new Uint8Array(12));
                
                // Encrypt
                const encryptedData = await crypto.subtle.encrypt(
                    { name: 'AES-GCM', iv: iv },
                    cryptoKey,
                    data
                );
                
                // Combine IV and encrypted data
                const combined = new Uint8Array(iv.length + encryptedData.byteLength);
                combined.set(iv);
                combined.set(new Uint8Array(encryptedData), iv.length);
                
                // Convert to base64
                encryptedContent = btoa(String.fromCharCode(...combined));
                isEncrypted = true;
                
                // Show result
                document.getElementById('resultPreview').textContent = 
                    encryptedContent.substring(0, 300) + (encryptedContent.length > 300 ? '...' : '');
                document.getElementById('fileResult').classList.remove('hidden');
                
                // Update stats
                document.getElementById('originalSize').textContent = formatFileSize(fileContent.length);
                document.getElementById('encryptedSize').textContent = formatFileSize(encryptedContent.length);
                document.getElementById('encryptionStats').classList.remove('hidden');
                
                // Update buttons
                document.getElementById('encryptBtn').disabled = true;
                document.getElementById('decryptBtn').disabled = false;
                
                // Show success message
                showNotification('‚úÖ File encrypted successfully!', 'success');
                
            } catch (error) {
                alert('Encryption failed: ' + error.message);
                console.error(error);
            }
        }

        async function decryptFile() {
            if (!encryptedContent) {
                alert('Please encrypt a file first');
                return;
            }
            
            const key = document.getElementById('encryptionKey').value;
            if (key.length < 32) {
                alert('Key must be at least 32 characters for AES-256');
                return;
            }
            
            try {
                const encoder = new TextEncoder();
                
                // Derive key from password
                const keyMaterial = await crypto.subtle.importKey(
                    'raw',
                    encoder.encode(key.padEnd(32, '0').substring(0, 32)),
                    'PBKDF2',
                    false,
                    ['deriveBits', 'deriveKey']
                );
                
                const cryptoKey = await crypto.subtle.deriveKey(
                    {
                        name: 'PBKDF2',
                        salt: encoder.encode('aes-demo-salt'),
                        iterations: 100000,
                        hash: 'SHA-256'
                    },
                    keyMaterial,
                    { name: 'AES-GCM', length: 256 },
                    true,
                    ['encrypt', 'decrypt']
                );
                
                // Decode base64
                const combined = new Uint8Array(
                    atob(encryptedContent).split('').map(c => c.charCodeAt(0))
                );
                
                // Extract IV and ciphertext
                const iv = combined.slice(0, 12);
                const ciphertext = combined.slice(12);
                
                // Decrypt
                const decryptedData = await crypto.subtle.decrypt(
                    { name: 'AES-GCM', iv: iv },
                    cryptoKey,
                    ciphertext
                );
                
                const decoder = new TextDecoder();
                const decrypted = decoder.decode(decryptedData);
                
                // Show result
                const preview = decrypted.substring(0, 300);
                document.getElementById('resultPreview').innerHTML = 
                    `<p class="whitespace-pre-wrap">${escapeHtml(preview)}${decrypted.length > 300 ? '...' : ''}</p>`;
                document.getElementById('fileResult').classList.remove('hidden');
                
                // Verify decryption
                if (decrypted === fileContent) {
                    showNotification('‚úÖ File decrypted successfully! Content matches original.', 'success');
                } else {
                    showNotification('‚ö†Ô∏è Decryption completed but content may differ', 'warning');
                }
                
                // Update for download
                encryptedContent = decrypted;
                isEncrypted = false;
                
            } catch (error) {
                alert('Decryption failed: ' + error.message + '\nMake sure you\'re using the correct key!');
                console.error(error);
            }
        }

        function downloadResult() {
            if (!encryptedContent) {
                alert('No result to download');
                return;
            }
            
            const blob = new Blob([encryptedContent], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = isEncrypted ? 
                uploadedFile.name.replace('.txt', '_encrypted.txt') : 
                uploadedFile.name.replace('.txt', '_decrypted.txt');
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function formatFileSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(2) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function showNotification(message, type) {
            const colors = {
                success: 'bg-green-500',
                warning: 'bg-yellow-500',
                error: 'bg-red-500'
            };
            
            const notification = document.createElement('div');
            notification.className = `fixed top-4 right-4 ${colors[type]} text-white px-6 py-3 rounded-lg shadow-lg z-50 transition-opacity`;
            notification.textContent = message;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.style.opacity = '0';
                setTimeout(() => notification.remove(), 300);
            }, 3000);
        }

        // Initialize grids
        let inputData = [];
        let outputData = [];
        let currentRound = 0;
        let isAnimating = false;

        // Initialize the application
        function init() {
            // Create input grid
            inputData = generateRandomBytes(16);
            outputData = Array(16).fill(0);
            
            renderGrid('inputGrid', inputData, 'bg-blue-600');
            renderGrid('outputGrid', outputData, 'bg-slate-700');
            
            // Create round indicators
            createRoundIndicators();
            
            // Initialize syntax highlighting
            hljs.highlightAll();
        }

        function generateRandomBytes(count) {
            const data = [];
            for (let i = 0; i < count; i++) {
                data.push(Math.floor(Math.random() * 256));
            }
            return data;
        }

        function renderGrid(gridId, data, colorClass) {
            const grid = document.getElementById(gridId);
            grid.innerHTML = '';
            
            for (let i = 0; i < 16; i++) {
                const cell = document.createElement('div');
                cell.className = `grid-cell ${colorClass} p-4 rounded text-center font-mono font-bold`;
                cell.textContent = data[i].toString(16).toUpperCase().padStart(2, '0');
                cell.id = `${gridId}-cell-${i}`;
                grid.appendChild(cell);
            }
        }

        function createRoundIndicators() {
            const container = document.getElementById('roundIndicators');
            container.innerHTML = '';
            
            for (let i = 0; i <= 14; i++) {
                const indicator = document.createElement('div');
                indicator.className = 'round-indicator w-8 h-8 bg-slate-700 rounded-full flex items-center justify-center text-sm font-bold';
                indicator.textContent = i;
                indicator.id = `round-${i}`;
                container.appendChild(indicator);
            }
        }

        async function startEncryption() {
            if (isAnimating) return;
            isAnimating = true;
            
            document.getElementById('inputLabel').textContent = 'Plaintext (16 bytes)';
            document.getElementById('outputLabel').textContent = 'Ciphertext';
            
            inputData = generateRandomBytes(16);
            outputData = [...inputData];
            
            renderGrid('inputGrid', inputData, 'bg-blue-600');
            renderGrid('outputGrid', outputData, 'bg-slate-700');
            
            currentRound = 0;
            
            for (let round = 0; round <= 14; round++) {
                currentRound = round;
                document.getElementById('roundNumber').textContent = round;
                updateRoundIndicator(round);
                
                // SubBytes
                await animateStep('SubBytes - Substituting bytes', 'outputGrid', 500);
                outputData = outputData.map(b => (b + 123) % 256);
                renderGrid('outputGrid', outputData, 'bg-purple-600');
                
                // ShiftRows
                await animateStep('ShiftRows - Shifting rows', 'outputGrid', 500);
                outputData = shiftRows(outputData);
                renderGrid('outputGrid', outputData, 'bg-green-600');
                
                // MixColumns (skip in final round)
                if (round < 14) {
                    await animateStep('MixColumns - Mixing columns', 'outputGrid', 500);
                    outputData = outputData.map(b => (b + 67) % 256);
                    renderGrid('outputGrid', outputData, 'bg-yellow-600');
                }
                
                // AddRoundKey
                await animateStep('AddRoundKey - Adding round key', 'outputGrid', 500);
                outputData = outputData.map(b => b ^ (round * 7 + 42));
                renderGrid('outputGrid', outputData, 'bg-red-600');
                
                await sleep(300);
            }
            
            document.getElementById('currentStep').textContent = 'Encryption complete! ‚úÖ';
            isAnimating = false;
        }

        async function startDecryption() {
            if (isAnimating) return;
            isAnimating = true;
            
            document.getElementById('inputLabel').textContent = 'Ciphertext';
            document.getElementById('outputLabel').textContent = 'Plaintext (16 bytes)';
            
            inputData = generateRandomBytes(16);
            outputData = [...inputData];
            
            renderGrid('inputGrid', inputData, 'bg-red-600');
            renderGrid('outputGrid', outputData, 'bg-slate-700');
            
            for (let round = 14; round >= 0; round--) {
                currentRound = round;
                document.getElementById('roundNumber').textContent = round;
                updateRoundIndicator(round);
                
                // Inverse operations in reverse order
                await animateStep('Inverse AddRoundKey', 'outputGrid', 500);
                outputData = outputData.map(b => b ^ (round * 7 + 42));
                renderGrid('outputGrid', outputData, 'bg-red-600');
                
                if (round < 14) {
                    await animateStep('Inverse MixColumns', 'outputGrid', 500);
                    outputData = outputData.map(b => (b - 67 + 256) % 256);
                    renderGrid('outputGrid', outputData, 'bg-yellow-600');
                }
                
                await animateStep('Inverse ShiftRows', 'outputGrid', 500);
                outputData = inverseShiftRows(outputData);
                renderGrid('outputGrid', outputData, 'bg-green-600');
                
                await animateStep('Inverse SubBytes', 'outputGrid', 500);
                outputData = outputData.map(b => (b - 123 + 256) % 256);
                renderGrid('outputGrid', outputData, 'bg-blue-600');
                
                await sleep(300);
            }
            
            document.getElementById('currentStep').textContent = 'Decryption complete! ‚úÖ';
            isAnimating = false;
        }

        function shiftRows(data) {
            const result = [...data];
            // Simulate row shifts in 4x4 grid
            // Row 0: no shift
            // Row 1: shift left by 1
            [result[4], result[5], result[6], result[7]] = [result[5], result[6], result[7], result[4]];
            // Row 2: shift left by 2
            [result[8], result[9], result[10], result[11]] = [result[10], result[11], result[8], result[9]];
            // Row 3: shift left by 3
            [result[12], result[13], result[14], result[15]] = [result[15], result[12], result[13], result[14]];
            return result;
        }

        function inverseShiftRows(data) {
            const result = [...data];
            // Row 1: shift right by 1
            [result[4], result[5], result[6], result[7]] = [result[7], result[4], result[5], result[6]];
            // Row 2: shift right by 2
            [result[8], result[9], result[10], result[11]] = [result[10], result[11], result[8], result[9]];
            // Row 3: shift right by 3
            [result[12], result[13], result[14], result[15]] = [result[13], result[14], result[15], result[12]];
            return result;
        }

        async function animateStep(stepName, gridId, duration) {
            document.getElementById('currentStep').textContent = stepName;
            
            // Highlight all cells
            for (let i = 0; i < 16; i++) {
                const cell = document.getElementById(`${gridId}-cell-${i}`);
                cell.classList.add('highlight');
            }
            
            await sleep(duration);
            
            // Remove highlight
            for (let i = 0; i < 16; i++) {
                const cell = document.getElementById(`${gridId}-cell-${i}`);
                cell.classList.remove('highlight');
            }
        }

        function updateRoundIndicator(round) {
            // Remove all active states
            for (let i = 0; i <= 14; i++) {
                document.getElementById(`round-${i}`).classList.remove('active');
            }
            // Add active to current round
            document.getElementById(`round-${round}`).classList.add('active');
        }

        function resetAnimation() {
            isAnimating = false;
            currentRound = 0;
            init();
            document.getElementById('roundNumber').textContent = '0';
            document.getElementById('currentStep').textContent = 'Ready to start';
            updateRoundIndicator(0);
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function showCode(lang) {
            // Update tabs
            document.getElementById('pythonTab').classList.remove('active');
            document.getElementById('nodejsTab').classList.remove('active');
            document.getElementById('javaTab').classList.remove('active');
            document.getElementById(`${lang}Tab`).classList.add('active');
            
            // Show/hide code
            document.getElementById('pythonCode').classList.add('hidden');
            document.getElementById('nodejsCode').classList.add('hidden');
            document.getElementById('javaCode').classList.add('hidden');
            document.getElementById(`${lang}Code`).classList.remove('hidden');
        }

        // Initialize on load
        window.onload = init;
    </script>
</body>
</html>
