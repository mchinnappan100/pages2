<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Ocean Greetings - Interactive Fish Tank</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      overflow: hidden;
      background: linear-gradient(to bottom, #001a33 0%, #003d66 100%);
    }

    #canvas-container {
      width: 100vw;
      height: 100vh;
      position: relative;
    }

    #greeting {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      color: white;
      font-size: 5rem;
      font-weight: bold;
      text-shadow: 0 0 20px rgba(0, 200, 255, 0.8),
                   0 0 40px rgba(0, 150, 255, 0.6),
                   0 0 60px rgba(0, 100, 255, 0.4);
      opacity: 0;
      animation: fadeIn 2s ease-in-out forwards;
      pointer-events: none;
      z-index: 100;
      letter-spacing: 3px;
      line-height: 1.3;
    }

    #greeting .name {
      display: block;
      font-size: 6rem;
      background: linear-gradient(45deg, #00d4ff, #0099ff, #00ffcc);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      animation: shimmer 3s ease-in-out infinite;
    }

    @keyframes fadeIn {
      0% {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.8);
      }
      50% {
        transform: translate(-50%, -50%) scale(1.1);
      }
      100% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
      }
    }

    @keyframes shimmer {
      0%, 100% {
        filter: hue-rotate(0deg) brightness(1);
      }
      50% {
        filter: hue-rotate(30deg) brightness(1.3);
      }
    }

    #info {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      color: rgba(255, 255, 255, 0.7);
      font-size: 14px;
      text-align: center;
      z-index: 10;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
    }

    @media (max-width: 768px) {
      #greeting {
        font-size: 3rem;
      }
      #greeting .name {
        font-size: 4rem;
      }
    }
  </style>
</head>
<body>
  <div id="canvas-container"></div>
  <div id="greeting"></div>
  <div id="info">üê† Click and drag to explore the ocean üê†</div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // Get parameters from URL
    const urlParams = new URLSearchParams(window.location.search);
    const personName = urlParams.get('p') || 'Friend';
    const greetingMsg = urlParams.get('g') || 'Greetings to';

    // Display greeting
    const greetingDiv = document.getElementById('greeting');
    greetingDiv.innerHTML = `
      ${greetingMsg}<br>
      <span class="name">${personName}</span>
    `;

    // Three.js setup
    let scene, camera, renderer, water, fish = [], bubbles = [], plants = [];
    let mouseX = 0, mouseY = 0;
    let targetRotationX = 0, targetRotationY = 0;

    function init() {
      // Scene
      scene = new THREE.Scene();
      scene.fog = new THREE.Fog(0x003d66, 10, 100);

      // Camera
      camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.z = 30;
      camera.position.y = 5;

      // Renderer
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0x001a33, 1);
      document.getElementById('canvas-container').appendChild(renderer.domElement);

      // Lighting
      const ambientLight = new THREE.AmbientLight(0x4080ff, 0.5);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(10, 20, 10);
      scene.add(directionalLight);

      const pointLight = new THREE.PointLight(0x00ffff, 1, 50);
      pointLight.position.set(0, 10, 0);
      scene.add(pointLight);

      // Create tank floor
      const floorGeometry = new THREE.PlaneGeometry(60, 60);
      const floorMaterial = new THREE.MeshPhongMaterial({
        color: 0x1a4d66,
        side: THREE.DoubleSide
      });
      const floor = new THREE.Mesh(floorGeometry, floorMaterial);
      floor.rotation.x = Math.PI / 2;
      floor.position.y = -10;
      scene.add(floor);

      // Create rocks/coral
      for (let i = 0; i < 15; i++) {
        const rockGeometry = new THREE.DodecahedronGeometry(Math.random() * 2 + 0.5);
        const rockMaterial = new THREE.MeshPhongMaterial({
          color: Math.random() > 0.5 ? 0x8B4513 : 0xFF6347
        });
        const rock = new THREE.Mesh(rockGeometry, rockMaterial);
        rock.position.set(
          (Math.random() - 0.5) * 50,
          -10 + Math.random() * 2,
          (Math.random() - 0.5) * 50
        );
        rock.rotation.set(
          Math.random() * Math.PI,
          Math.random() * Math.PI,
          Math.random() * Math.PI
        );
        scene.add(rock);
      }

      // Create seaweed/plants
      for (let i = 0; i < 20; i++) {
        const plant = createPlant();
        plant.position.set(
          (Math.random() - 0.5) * 50,
          -10,
          (Math.random() - 0.5) * 50
        );
        plants.push(plant);
        scene.add(plant);
      }

      // Create fish
      for (let i = 0; i < 25; i++) {
        const fishObj = createFish();
        fish.push(fishObj);
        scene.add(fishObj.mesh);
      }

      // Create bubbles
      for (let i = 0; i < 50; i++) {
        const bubble = createBubble();
        bubbles.push(bubble);
        scene.add(bubble.mesh);
      }

      // Mouse interaction
      document.addEventListener('mousemove', onMouseMove, false);
      window.addEventListener('resize', onWindowResize, false);
    }

    function createFish() {
      const fishGroup = new THREE.Group();

      // More realistic body proportions
      const bodyGeometry = new THREE.SphereGeometry(1, 32, 32);
      bodyGeometry.scale(2, 1, 0.7);
      
      // Different fish species with realistic colors
      const fishTypes = [
        { color: 0xFFA500, stripeColor: 0xFFFFFF, name: 'Clownfish' }, // Orange with white
        { color: 0x4169E1, stripeColor: 0xFFFF00, name: 'Blue Tang' }, // Blue with yellow
        { color: 0xFF1493, stripeColor: 0xFF69B4, name: 'Pink Fish' }, // Pink
        { color: 0xFFD700, stripeColor: 0xFFA500, name: 'Goldfish' }, // Gold
        { color: 0x00CED1, stripeColor: 0x40E0D0, name: 'Turquoise' }, // Turquoise
        { color: 0x9370DB, stripeColor: 0xBA55D3, name: 'Purple Fish' }, // Purple
        { color: 0x32CD32, stripeColor: 0x90EE90, name: 'Green Fish' }, // Green
      ];
      
      const fishType = fishTypes[Math.floor(Math.random() * fishTypes.length)];
      
      const bodyMaterial = new THREE.MeshPhongMaterial({
        color: fishType.color,
        shininess: 80,
        specular: 0x222222
      });
      const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
      fishGroup.add(body);

      // Add stripes for more realistic look (like clownfish)
      if (Math.random() > 0.5) {
        for (let i = 0; i < 2; i++) {
          const stripeGeometry = new THREE.TorusGeometry(1, 0.15, 16, 32);
          stripeGeometry.scale(2, 1, 0.7);
          const stripeMaterial = new THREE.MeshPhongMaterial({
            color: fishType.stripeColor,
            shininess: 80
          });
          const stripe = new THREE.Mesh(stripeGeometry, stripeMaterial);
          stripe.position.x = -0.8 + i * 1.2;
          stripe.rotation.y = Math.PI / 2;
          fishGroup.add(stripe);
        }
      }

      // More realistic tail fin - forked/crescent shape
      const tailShape = new THREE.Shape();
      tailShape.moveTo(0, 0);
      tailShape.quadraticCurveTo(-0.5, 0.8, -1, 1.2);
      tailShape.lineTo(-1.2, 1);
      tailShape.quadraticCurveTo(-0.6, 0.3, -0.2, 0);
      tailShape.quadraticCurveTo(-0.6, -0.3, -1.2, -1);
      tailShape.lineTo(-1, -1.2);
      tailShape.quadraticCurveTo(-0.5, -0.8, 0, 0);
      
      const tailGeometry = new THREE.ExtrudeGeometry(tailShape, {
        depth: 0.1,
        bevelEnabled: false
      });
      const tailMaterial = new THREE.MeshPhongMaterial({
        color: fishType.color,
        shininess: 80,
        transparent: true,
        opacity: 0.8
      });
      const tail = new THREE.Mesh(tailGeometry, tailMaterial);
      tail.position.x = -2;
      tail.position.z = -0.05;
      fishGroup.add(tail);

      // Dorsal fin (top fin)
      const dorsalFinShape = new THREE.Shape();
      dorsalFinShape.moveTo(0, 0);
      dorsalFinShape.quadraticCurveTo(0.2, 0.8, 0.5, 1.2);
      dorsalFinShape.lineTo(0.4, 1.1);
      dorsalFinShape.quadraticCurveTo(0.15, 0.6, 0, 0);
      
      const dorsalGeometry = new THREE.ExtrudeGeometry(dorsalFinShape, {
        depth: 0.05,
        bevelEnabled: false
      });
      const dorsalFin = new THREE.Mesh(dorsalGeometry, tailMaterial);
      dorsalFin.position.set(0, 0.8, -0.025);
      dorsalFin.rotation.x = -0.3;
      fishGroup.add(dorsalFin);

      // Pectoral fins (side fins) - left and right
      const pectoralFinShape = new THREE.Shape();
      pectoralFinShape.moveTo(0, 0);
      pectoralFinShape.quadraticCurveTo(0.5, 0.3, 0.8, 0.6);
      pectoralFinShape.lineTo(0.7, 0.5);
      pectoralFinShape.quadraticCurveTo(0.4, 0.2, 0, 0);
      
      const pectoralGeometry = new THREE.ExtrudeGeometry(pectoralFinShape, {
        depth: 0.02,
        bevelEnabled: false
      });
      
      const leftFin = new THREE.Mesh(pectoralGeometry, tailMaterial);
      leftFin.position.set(0.5, 0, 0.7);
      leftFin.rotation.set(0.3, 0, -0.5);
      fishGroup.add(leftFin);
      
      const rightFin = new THREE.Mesh(pectoralGeometry, tailMaterial);
      rightFin.position.set(0.5, 0, -0.7);
      rightFin.rotation.set(-0.3, 0, 0.5);
      rightFin.scale.z = -1;
      fishGroup.add(rightFin);

      // Anal fin (bottom fin)
      const analFin = new THREE.Mesh(dorsalGeometry, tailMaterial);
      analFin.position.set(-0.5, -0.8, -0.025);
      analFin.rotation.set(Math.PI, 0, 0.3);
      analFin.scale.set(0.7, 0.7, 0.7);
      fishGroup.add(analFin);

      // More realistic eyes with iris
      const eyeGeometry = new THREE.SphereGeometry(0.2, 16, 16);
      const eyeMaterial = new THREE.MeshPhongMaterial({ color: 0xFFFFFF });
      
      const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
      leftEye.position.set(1.5, 0.3, 0.5);
      fishGroup.add(leftEye);
      
      const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
      rightEye.position.set(1.5, 0.3, -0.5);
      fishGroup.add(rightEye);

      // Pupils
      const pupilGeometry = new THREE.SphereGeometry(0.1, 16, 16);
      const pupilMaterial = new THREE.MeshPhongMaterial({ color: 0x000000 });
      
      const leftPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
      leftPupil.position.set(1.65, 0.3, 0.5);
      fishGroup.add(leftPupil);
      
      const rightPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
      rightPupil.position.set(1.65, 0.3, -0.5);
      fishGroup.add(rightPupil);

      // Add subtle mouth
      const mouthGeometry = new THREE.SphereGeometry(0.15, 8, 8);
      const mouthMaterial = new THREE.MeshPhongMaterial({ 
        color: 0x000000,
        transparent: true,
        opacity: 0.3
      });
      const mouth = new THREE.Mesh(mouthGeometry, mouthMaterial);
      mouth.scale.set(1, 0.5, 0.8);
      mouth.position.set(1.8, -0.1, 0);
      fishGroup.add(mouth);

      // Random size variation for natural look
      const scale = 0.4 + Math.random() * 0.6;
      fishGroup.scale.set(scale, scale, scale);
      
      fishGroup.position.set(
        (Math.random() - 0.5) * 50,
        (Math.random() - 0.5) * 20,
        (Math.random() - 0.5) * 50
      );

      return {
        mesh: fishGroup,
        velocity: new THREE.Vector3(
          (Math.random() - 0.5) * 0.15,
          (Math.random() - 0.5) * 0.08,
          (Math.random() - 0.5) * 0.15
        ),
        rotationSpeed: (Math.random() - 0.5) * 0.02,
        tailSwing: 0,
        finSwing: 0
      };
    }

    function createBubble() {
      const geometry = new THREE.SphereGeometry(Math.random() * 0.3 + 0.1, 8, 8);
      const material = new THREE.MeshPhongMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 0.4,
        shininess: 100
      });
      const bubble = new THREE.Mesh(geometry, material);

      bubble.position.set(
        (Math.random() - 0.5) * 50,
        -10 + Math.random() * 5,
        (Math.random() - 0.5) * 50
      );

      return {
        mesh: bubble,
        speed: Math.random() * 0.05 + 0.02
      };
    }

    function createPlant() {
      const plantGroup = new THREE.Group();
      const segments = 8;
      const height = Math.random() * 4 + 3;

      for (let i = 0; i < segments; i++) {
        const segmentGeometry = new THREE.CylinderGeometry(
          0.1 - i * 0.01,
          0.15 - i * 0.01,
          height / segments,
          8
        );
        const segmentMaterial = new THREE.MeshPhongMaterial({
          color: i % 2 === 0 ? 0x2d5016 : 0x3d6b1f
        });
        const segment = new THREE.Mesh(segmentGeometry, segmentMaterial);
        segment.position.y = (i * height) / segments;
        plantGroup.add(segment);
      }

      return plantGroup;
    }

    function onMouseMove(event) {
      mouseX = (event.clientX / window.innerWidth) * 2 - 1;
      mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
      
      targetRotationX = mouseY * 0.3;
      targetRotationY = mouseX * 0.5;
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      requestAnimationFrame(animate);

      // Smooth camera rotation
      camera.rotation.x += (targetRotationX - camera.rotation.x) * 0.05;
      camera.rotation.y += (targetRotationY - camera.rotation.y) * 0.05;

      // Animate fish
      fish.forEach((fishObj) => {
        // Move fish
        fishObj.mesh.position.add(fishObj.velocity);

        // Boundary check
        if (Math.abs(fishObj.mesh.position.x) > 25) {
          fishObj.velocity.x *= -1;
          fishObj.mesh.rotation.y += Math.PI;
        }
        if (Math.abs(fishObj.mesh.position.y) > 15) {
          fishObj.velocity.y *= -1;
        }
        if (Math.abs(fishObj.mesh.position.z) > 25) {
          fishObj.velocity.z *= -1;
          fishObj.mesh.rotation.y += Math.PI;
        }

        // Realistic tail animation (side-to-side swishing)
        fishObj.tailSwing += 0.15;
        if (fishObj.mesh.children[2]) { // Tail fin
          fishObj.mesh.children[2].rotation.y = Math.sin(fishObj.tailSwing) * 0.4;
        }

        // Pectoral fins animation (flapping)
        fishObj.finSwing += 0.1;
        if (fishObj.mesh.children[4]) { // Left pectoral fin
          fishObj.mesh.children[4].rotation.z = -0.5 + Math.sin(fishObj.finSwing) * 0.3;
        }
        if (fishObj.mesh.children[5]) { // Right pectoral fin
          fishObj.mesh.children[5].rotation.z = 0.5 + Math.sin(fishObj.finSwing) * 0.3;
        }

        // Natural swimming motion - slight up and down bobbing
        fishObj.mesh.position.y += Math.sin(fishObj.tailSwing * 0.5) * 0.02;
        
        // Slight roll as fish swims
        fishObj.mesh.rotation.z = Math.sin(fishObj.tailSwing * 0.5) * 0.08;
        
        // Fish tilts slightly in direction of movement
        const velocityAngle = Math.atan2(fishObj.velocity.y, 
          Math.sqrt(fishObj.velocity.x ** 2 + fishObj.velocity.z ** 2));
        fishObj.mesh.rotation.x = velocityAngle * 0.5;
      });

      // Animate bubbles
      bubbles.forEach((bubble) => {
        bubble.mesh.position.y += bubble.speed;
        
        // Wobble effect
        bubble.mesh.position.x += Math.sin(Date.now() * 0.001 + bubble.mesh.position.y) * 0.02;

        // Reset bubble when it reaches top
        if (bubble.mesh.position.y > 20) {
          bubble.mesh.position.y = -10;
          bubble.mesh.position.x = (Math.random() - 0.5) * 50;
          bubble.mesh.position.z = (Math.random() - 0.5) * 50;
        }
      });

      // Animate plants (gentle swaying)
      plants.forEach((plant, index) => {
        plant.rotation.z = Math.sin(Date.now() * 0.001 + index) * 0.1;
      });

      renderer.render(scene, camera);
    }

    // Initialize and start animation
    init();
    animate();
  </script>
</body>
</html>